<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CDNetworks API: QueryDomainHit / HitRatio / BWSavingRatio / BWTrafficEdge / BWTrafficRequest / BWTrafficBackToOrigin / RequestBackToOrigin - Graph</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        body {
            font-family: "Inter", sans-serif;
            background-color: #f4f4f9;
            color: #333;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .container {
            background: #fff;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            width: 100%;
            max-width: 900px;
        }
        h1 {
            color: #4a90e2;
            text-align: center;
            margin-bottom: 20px;
        }
        .form-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        input[type="date"], select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 5px;
            box-sizing: border-box;
        }
        .btn {
            background-color: #4a90e2;
            color: white;
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease;
            width: 100%;
            font-weight: bold;
        }
        .btn:hover {
            background-color: #357ab8;
        }
        .btn:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        .chart-container {
            width: 100%;
            height: 400px;
            margin-top: 20px;
            background: #f9f9f9;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
        }
        .raw-data-container {
            margin-top: 20px;
            padding: 15px;
            background: #f0f0f5;
            border-radius: 8px;
            border: 1px solid #d0d0d5;
            display: none;
            overflow-x: auto;
        }
        .data-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
        }
        .loading-spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border-left-color: #4a90e2;
            animation: spin 1s ease infinite;
            display: none;
            margin: 20px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .summary-box {
            background-color: #e3f2fd;
            border: 1px solid #bbdefb;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            text-align: left;
        }
        .summary-box h4 {
            font-weight: bold;
            color: #1565c0;
            margin-bottom: 10px;
        }
        .summary-box p {
            margin: 5px 0;
            font-size: 0.9rem;
        }
        .summary-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
    </style>
</head>
<body class="bg-gray-100 p-8 flex flex-col items-center">
    <div class="container bg-white p-8 rounded-xl shadow-lg w-full">
        <h1 class="text-3xl font-bold text-center text-blue-500 mb-6">CDNetworks API Data Graphing Tool</h1>
        <div class="flex flex-col md:flex-row md:space-x-4 mb-6">
            <div class="form-group flex-1">
                <label for="dataType" class="block text-sm font-semibold text-gray-700 mb-1">Select Data Type:</label>
                <select id="dataType" class="w-full px-4 py-2 border rounded-md focus:outline-none focus:ring focus:ring-blue-200">
                    <option value="domainHit">Domain Total Request</option>
                    <option value="hitRatio">Hit Ratio</option>
                    <option value="bwSavingRatio">BW Saving Ratio</option>
                    <option value="bwTrafficEdge">BW Traffic (Edge)</option>
                    <option value="bwTrafficRequest">BW Traffic (Request)</option>
                    <option value="bwTrafficBackToOrigin">BW Traffic (Back to Origin)</option>
                    <option value="requestBackToOrigin">Request (Back to Origin)</option>
                </select>
            </div>
            <div class="form-group flex-1">
                <label for="dateFrom" class="block text-sm font-semibold text-gray-700 mb-1">From Date:</label>
                <input type="date" id="dateFrom" class="w-full px-4 py-2 border rounded-md focus:outline-none focus:ring focus:ring-blue-200">
            </div>
            <div class="form-group flex-1">
                <label for="dateTo" class="block text-sm font-semibold text-gray-700 mb-1">To Date:</label>
                <input type="date" id="dateTo" class="w-full px-4 py-2 border rounded-md focus:outline-none focus:ring focus:ring-blue-200">
            </div>
        </div>
        <div class="flex flex-col md:flex-row md:space-x-4 space-y-4 md:space-y-0 mb-6">
            <button id="loadGraphButton" class="btn bg-blue-500 hover:bg-blue-600 focus:outline-none focus:ring focus:ring-blue-200">Load Selected Graph</button>
            <button id="generateAllGraphsButton" class="btn bg-green-500 hover:bg-green-600 focus:outline-none focus:ring focus:ring-green-200">Generate All Graphs</button>
            <button id="saveAsPdfButton" class="btn bg-red-500 hover:bg-red-600 focus:outline-none focus:ring focus:ring-red-200" disabled>Save as PDF</button>
        </div>
        <div id="loadingSpinner" class="loading-spinner"></div>
        <div id="chartsContainer" class="data-grid">
            </div>
        
        <div id="summaryStatisticsContainer" class="summary-container">
            </div>
        
        <button id="toggleRawDataButton" class="btn bg-gray-500 hover:bg-gray-600 focus:outline-none focus:ring focus:ring-gray-200 mt-6">Show Raw Data</button>
        <div id="resultContainer" class="raw-data-container bg-gray-200 text-gray-800 rounded-md p-4 mt-4">
            </div>
    </div>
<script>
    const charts = {};
    const fileMap = {
        'domainHit': 'Domain_request.json',
        'hitRatio': 'hitRatio.json',
        'bwSavingRatio': 'savedBandwidthRatio.json',
        'bwTrafficEdge': 'bw-traffic_Edge_update.json',
        'bwTrafficRequest': 'bw-traffic_requests_update.json',
        'bwTrafficBackToOrigin': 'traffic-requests_origin.json',
        'requestBackToOrigin': 'traffic-requests_origin.json'
    };

    function filterDataByDate(data, dateFrom, dateTo) {
        const fromDate = new Date(dateFrom);
        const toDate = new Date(dateTo);
        toDate.setDate(toDate.getDate() + 1);
        return data.filter(item => {
            const itemDate = new Date(item.timestamp);
            return itemDate >= fromDate && itemDate < toDate;
        });
    }

    function createSummaryBox(title, totalValue, totalLabel, maxValue, maxLabel, maxTimestamp) {
        const summaryBox = document.createElement('div');
        summaryBox.className = 'summary-box';
        summaryBox.innerHTML = `
            <h4>${title} Summary Statistics</h4>
            <p><strong>Total ${totalLabel}:</strong> ${totalValue.toFixed(2)}</p>
            <p><strong>Max ${maxLabel}:</strong> ${maxValue.toFixed(2)} at ${maxTimestamp}</p>
        `;
        return summaryBox;
    }

    function createChart(config) {
        const { canvasId, title, label, borderColor, labels, data } = config;
        const ctx = document.getElementById(canvasId);

        if (charts[canvasId]) {
            charts[canvasId].destroy();
        }

        charts[canvasId] = new Chart(ctx, {
            type: 'line',
            data: {
                labels: labels,
                datasets: [{
                    label: label,
                    data: data,
                    borderColor: borderColor,
                    borderWidth: 2,
                    fill: false,
                    tension: 0.1
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: true,
                        text: title
                    }
                },
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'Timestamp'
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: label
                        }
                    }
                }
            }
        });
    }

    function calculateSummary(filteredData, valueKey) {
        if (!filteredData || filteredData.length === 0) {
            return { total: 0, max: 0, maxTimestamp: 'N/A' };
        }
        let total = 0;
        let max = -Infinity;
        let maxTimestamp = '';

        filteredData.forEach(item => {
            const value = parseFloat(item[valueKey]);
            total += value;
            if (value > max) {
                max = value;
                maxTimestamp = item.timestamp;
            }
        });
        return { total, max, maxTimestamp };
    }

    async function loadSingleGraph(dataType) {
        const spinner = document.getElementById('loadingSpinner');
        const chartsContainer = document.getElementById('chartsContainer');
        const summaryContainer = document.getElementById('summaryStatisticsContainer');
        const resultContainer = document.getElementById('resultContainer');
        const saveAsPdfButton = document.getElementById('saveAsPdfButton');
        const dateFrom = document.getElementById('dateFrom').value;
        const dateTo = document.getElementById('dateTo').value;

        chartsContainer.innerHTML = '';
        summaryContainer.innerHTML = '';
        chartsContainer.style.display = 'block';
        saveAsPdfButton.disabled = true;

        const canvasContainer = document.createElement('div');
        canvasContainer.className = 'chart-container';
        canvasContainer.innerHTML = `<canvas id="singleChartCanvas"></canvas>`;
        chartsContainer.appendChild(canvasContainer);

        spinner.style.display = 'block';
        resultContainer.style.display = 'none';

        try {
            const url = fileMap[dataType];
            if (!url) {
                chartsContainer.innerHTML = `<p class="text-center text-red-500">Error: No data file found for this type.</p>`;
                return;
            }

            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const rawData = await response.json();

            resultContainer.innerHTML = `<pre class="whitespace-pre-wrap">${JSON.stringify(rawData, null, 2)}</pre>`;
            document.getElementById('toggleRawDataButton').textContent = 'Show Raw Data';

            let filteredData = [];
            let chartConfig = {};
            let summary = {};

            switch (dataType) {
                case 'domainHit':
                    filteredData = filterDataByDate(rawData['hit-report']['hit-data'], dateFrom, dateTo);
                    summary = calculateSummary(filteredData, 'hit');
                    chartConfig = {
                        canvasId: 'singleChartCanvas',
                        title: 'Domain Total Request',
                        label: 'Total Requests',
                        borderColor: '#4a90e2',
                        labels: filteredData.map(item => item.timestamp),
                        data: filteredData.map(item => parseInt(item.hit)),
                    };
                    summaryContainer.appendChild(createSummaryBox('Domain Total Request', summary.total, 'Requests', summary.max, 'Requests', summary.maxTimestamp));
                    break;
                case 'hitRatio':
                    filteredData = filterDataByDate(rawData.data[0].hitRatioDatas, dateFrom, dateTo);
                    const hitRatioData = filteredData.map(item => parseFloat(item.hitRatio) * 100);
                    const hitRatioSum = hitRatioData.reduce((sum, val) => sum + val, 0);
                    const hitRatioMax = Math.max(...hitRatioData);
                    const hitRatioMaxTimestamp = filteredData.find(item => parseFloat(item.hitRatio) * 100 === hitRatioMax)?.timestamp || 'N/A';
                    chartConfig = {
                        canvasId: 'singleChartCanvas',
                        title: 'Hit Ratio',
                        label: 'Hit Ratio (%)',
                        borderColor: '#50c878',
                        labels: filteredData.map(item => item.timestamp),
                        data: hitRatioData,
                    };
                    summaryContainer.appendChild(createSummaryBox('Hit Ratio', hitRatioSum, 'Hit Ratio (%)', hitRatioMax, 'Hit Ratio (%)', hitRatioMaxTimestamp));
                    break;
                case 'bwSavingRatio':
                    filteredData = filterDataByDate(rawData.data[0].dataSeries, dateFrom, dateTo);
                    const savingRatioData = filteredData.map(item => parseFloat(item.savedBandwidthRatio) * 100);
                    const savingRatioSum = savingRatioData.reduce((sum, val) => sum + val, 0);
                    const savingRatioMax = Math.max(...savingRatioData);
                    const savingRatioMaxTimestamp = filteredData.find(item => parseFloat(item.savedBandwidthRatio) * 100 === savingRatioMax)?.timestamp || 'N/A';
                    chartConfig = {
                        canvasId: 'singleChartCanvas',
                        title: 'Bandwidth Saving Ratio',
                        label: 'Saving Ratio (%)',
                        borderColor: '#ffa500',
                        labels: filteredData.map(item => item.timestamp),
                        data: savingRatioData,
                    };
                    summaryContainer.appendChild(createSummaryBox('Bandwidth Saving Ratio', savingRatioSum, 'Saving Ratio (%)', savingRatioMax, 'Saving Ratio (%)', savingRatioMaxTimestamp));
                    break;
                case 'bwTrafficEdge':
                    filteredData = filterDataByDate(rawData.result[0].dataSeries, dateFrom, dateTo);
                    summary = calculateSummary(filteredData, 'bandwidth');
                    chartConfig = {
                        canvasId: 'singleChartCanvas',
                        title: 'Bandwidth Traffic (Edge)',
                        label: 'Bandwidth (Mbps)',
                        borderColor: '#8a2be2',
                        labels: filteredData.map(item => item.timestamp),
                        data: filteredData.map(item => parseFloat(item.bandwidth)),
                    };
                    summaryContainer.appendChild(createSummaryBox('Bandwidth Traffic (Edge)', summary.total, 'Bandwidth (Mbps)', summary.max, 'Bandwidth (Mbps)', summary.maxTimestamp));
                    break;
                case 'bwTrafficRequest':
                    filteredData = filterDataByDate(rawData.result[0].dataSeries, dateFrom, dateTo);
                    summary = calculateSummary(filteredData, 'requests');
                    chartConfig = {
                        canvasId: 'singleChartCanvas',
                        title: 'Request Traffic',
                        label: 'Requests',
                        borderColor: '#4a90e2',
                        labels: filteredData.map(item => item.timestamp),
                        data: filteredData.map(item => parseInt(item.requests)),
                    };
                    summaryContainer.appendChild(createSummaryBox('Request Traffic', summary.total, 'Requests', summary.max, 'Requests', summary.maxTimestamp));
                    break;
                case 'bwTrafficBackToOrigin':
                    filteredData = filterDataByDate(rawData.result[0].dataSeries, dateFrom, dateTo);
                    summary = calculateSummary(filteredData, 'bandwidth');
                    chartConfig = {
                        canvasId: 'singleChartCanvas',
                        title: 'Bandwidth Traffic (Back to Origin)',
                        label: 'Bandwidth (Mbps)',
                        borderColor: '#ff6384',
                        labels: filteredData.map(item => item.timestamp),
                        data: filteredData.map(item => parseFloat(item.bandwidth)),
                    };
                    summaryContainer.appendChild(createSummaryBox('Bandwidth Traffic (Back to Origin)', summary.total, 'Bandwidth (Mbps)', summary.max, 'Bandwidth (Mbps)', summary.maxTimestamp));
                    break;
                case 'requestBackToOrigin':
                    filteredData = filterDataByDate(rawData.result[0].dataSeries, dateFrom, dateTo);
                    summary = calculateSummary(filteredData, 'requests');
                    chartConfig = {
                        canvasId: 'singleChartCanvas',
                        title: 'Requests (Back to Origin)',
                        label: 'Requests',
                        borderColor: '#36a2eb',
                        labels: filteredData.map(item => item.timestamp),
                        data: filteredData.map(item => parseInt(item.requests)),
                    };
                    summaryContainer.appendChild(createSummaryBox('Requests (Back to Origin)', summary.total, 'Requests', summary.max, 'Requests', summary.maxTimestamp));
                    break;
                default:
                    chartsContainer.innerHTML = `<p class="text-center text-red-500">Error: Invalid data type selected.</p>`;
                    return;
            }
            createChart(chartConfig);
            saveAsPdfButton.disabled = false;
        } catch (error) {
            console.error('Fetch or parsing error:', error);
            chartsContainer.innerHTML = `<p class="text-center text-red-500">Failed to load data: ${error.message}</p>`;
        } finally {
            spinner.style.display = 'none';
        }
    }

    async function generateAllGraphs() {
        const spinner = document.getElementById('loadingSpinner');
        const chartsContainer = document.getElementById('chartsContainer');
        const summaryContainer = document.getElementById('summaryStatisticsContainer');
        const resultContainer = document.getElementById('resultContainer');
        const saveAsPdfButton = document.getElementById('saveAsPdfButton');
        const dateFrom = document.getElementById('dateFrom').value;
        const dateTo = document.getElementById('dateTo').value;

        for (const chartId in charts) {
            if (charts[chartId]) {
                charts[chartId].destroy();
            }
        }
        chartsContainer.innerHTML = '';
        summaryContainer.innerHTML = '';
        resultContainer.style.display = 'none';
        saveAsPdfButton.disabled = true;
        spinner.style.display = 'block';

        const dataTypes = Object.keys(fileMap);
        let allRawData = {};

        try {
            const fetchPromises = dataTypes.map(async (type) => {
                const url = fileMap[type];
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status} for ${url}`);
                }
                const data = await response.json();
                allRawData[type] = data;
                return data;
            });

            await Promise.all(fetchPromises);
            let rawDataHtml = '';
            for (const type in allRawData) {
                rawDataHtml += `<h3 class="font-bold text-lg mt-4 mb-2">${type} Data</h3>`;
                rawDataHtml += `<pre class="whitespace-pre-wrap">${JSON.stringify(allRawData[type], null, 2)}</pre>`;
            }
            resultContainer.innerHTML = rawDataHtml;
            document.getElementById('toggleRawDataButton').textContent = 'Show Raw Data';

            dataTypes.forEach(dataType => {
                const data = allRawData[dataType];
                let filteredData = [];
                let chartConfig = {};
                let summary = {};
                const canvasId = `chartCanvas-${dataType}`;
                const canvasContainer = document.createElement('div');
                canvasContainer.className = 'chart-container';
                canvasContainer.innerHTML = `<canvas id="${canvasId}"></canvas>`;
                chartsContainer.appendChild(canvasContainer);

                switch (dataType) {
                    case 'domainHit':
                        filteredData = filterDataByDate(data['hit-report']['hit-data'], dateFrom, dateTo);
                        summary = calculateSummary(filteredData, 'hit');
                        chartConfig = {
                            canvasId: canvasId,
                            title: 'Domain Total Request',
                            label: 'Total Requests',
                            borderColor: '#4a90e2',
                            labels: filteredData.map(item => item.timestamp),
                            data: filteredData.map(item => parseInt(item.hit)),
                        };
                        summaryContainer.appendChild(createSummaryBox('Domain Total Request', summary.total, 'Requests', summary.max, 'Requests', summary.maxTimestamp));
                        break;
                    case 'hitRatio':
                        filteredData = filterDataByDate(data.data[0].hitRatioDatas, dateFrom, dateTo);
                        const hitRatioData = filteredData.map(item => parseFloat(item.hitRatio) * 100);
                        const hitRatioSum = hitRatioData.reduce((sum, val) => sum + val, 0);
                        const hitRatioMax = Math.max(...hitRatioData);
                        const hitRatioMaxTimestamp = filteredData.find(item => parseFloat(item.hitRatio) * 100 === hitRatioMax)?.timestamp || 'N/A';
                        chartConfig = {
                            canvasId: canvasId,
                            title: 'Hit Ratio',
                            label: 'Hit Ratio (%)',
                            borderColor: '#50c878',
                            labels: filteredData.map(item => item.timestamp),
                            data: hitRatioData,
                        };
                        summaryContainer.appendChild(createSummaryBox('Hit Ratio', hitRatioSum, 'Hit Ratio (%)', hitRatioMax, 'Hit Ratio (%)', hitRatioMaxTimestamp));
                        break;
                    case 'bwSavingRatio':
                        filteredData = filterDataByDate(data.data[0].dataSeries, dateFrom, dateTo);
                        const savingRatioData = filteredData.map(item => parseFloat(item.savedBandwidthRatio) * 100);
                        const savingRatioSum = savingRatioData.reduce((sum, val) => sum + val, 0);
                        const savingRatioMax = Math.max(...savingRatioData);
                        const savingRatioMaxTimestamp = filteredData.find(item => parseFloat(item.savedBandwidthRatio) * 100 === savingRatioMax)?.timestamp || 'N/A';
                        chartConfig = {
                            canvasId: canvasId,
                            title: 'Bandwidth Saving Ratio',
                            label: 'Saving Ratio (%)',
                            borderColor: '#ffa500',
                            labels: filteredData.map(item => item.timestamp),
                            data: savingRatioData,
                        };
                        summaryContainer.appendChild(createSummaryBox('Bandwidth Saving Ratio', savingRatioSum, 'Saving Ratio (%)', savingRatioMax, 'Saving Ratio (%)', savingRatioMaxTimestamp));
                        break;
                    case 'bwTrafficEdge':
                        filteredData = filterDataByDate(data.result[0].dataSeries, dateFrom, dateTo);
                        summary = calculateSummary(filteredData, 'bandwidth');
                        chartConfig = {
                            canvasId: canvasId,
                            title: 'Bandwidth Traffic (Edge)',
                            label: 'Bandwidth (Mbps)',
                            borderColor: '#8a2be2',
                            labels: filteredData.map(item => item.timestamp),
                            data: filteredData.map(item => parseFloat(item.bandwidth)),
                        };
                        summaryContainer.appendChild(createSummaryBox('Bandwidth Traffic (Edge)', summary.total, 'Bandwidth (Mbps)', summary.max, 'Bandwidth (Mbps)', summary.maxTimestamp));
                        break;
                    case 'bwTrafficRequest':
                        filteredData = filterDataByDate(data.result[0].dataSeries, dateFrom, dateTo);
                        summary = calculateSummary(filteredData, 'requests');
                        chartConfig = {
                            canvasId: canvasId,
                            title: 'Request Traffic',
                            label: 'Requests',
                            borderColor: '#4a90e2',
                            labels: filteredData.map(item => item.timestamp),
                            data: filteredData.map(item => parseInt(item.requests)),
                        };
                        summaryContainer.appendChild(createSummaryBox('Request Traffic', summary.total, 'Requests', summary.max, 'Requests', summary.maxTimestamp));
                        break;
                    case 'bwTrafficBackToOrigin':
                        filteredData = filterDataByDate(data.result[0].dataSeries, dateFrom, dateTo);
                        summary = calculateSummary(filteredData, 'bandwidth');
                        chartConfig = {
                            canvasId: canvasId,
                            title: 'Bandwidth Traffic (Back to Origin)',
                            label: 'Bandwidth (Mbps)',
                            borderColor: '#ff6384',
                            labels: filteredData.map(item => item.timestamp),
                            data: filteredData.map(item => parseFloat(item.bandwidth)),
                        };
                        summaryContainer.appendChild(createSummaryBox('Bandwidth Traffic (Back to Origin)', summary.total, 'Bandwidth (Mbps)', summary.max, 'Bandwidth (Mbps)', summary.maxTimestamp));
                        break;
                    case 'requestBackToOrigin':
                        filteredData = filterDataByDate(data.result[0].dataSeries, dateFrom, dateTo);
                        summary = calculateSummary(filteredData, 'requests');
                        chartConfig = {
                            canvasId: canvasId,
                            title: 'Requests (Back to Origin)',
                            label: 'Requests',
                            borderColor: '#36a2eb',
                            labels: filteredData.map(item => item.timestamp),
                            data: filteredData.map(item => parseInt(item.requests)),
                        };
                        summaryContainer.appendChild(createSummaryBox('Requests (Back to Origin)', summary.total, 'Requests', summary.max, 'Requests', summary.maxTimestamp));
                        break;
                }
                createChart(chartConfig);
            });
            saveAsPdfButton.disabled = false;
        } catch (error) {
            console.error('Failed to generate all graphs:', error);
            chartsContainer.innerHTML = `<p class="text-center text-red-500">Failed to load data for one or more graphs: ${error.message}</p>`;
        } finally {
            spinner.style.display = 'none';
        }
    }

    async function saveAsPdf() {
        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF('p', 'mm', 'a4');
        const chartsContainer = document.getElementById('chartsContainer');
        const summaryContainer = document.getElementById('summaryStatisticsContainer');
        const charts = chartsContainer.querySelectorAll('.chart-container');
        const margin = 10;
        let yOffset = margin;
        
        pdf.setFontSize(24);
        pdf.text('CDN Data Report', 105, yOffset, null, null, 'center');
        yOffset += 20;
        
        // Add all chart canvases to the PDF
        for (const chartDiv of charts) {
            const canvas = chartDiv.querySelector('canvas');
            if (canvas) {
                const imgData = canvas.toDataURL('image/png');
                const imgProps = pdf.getImageProperties(imgData);
                const pdfWidth = pdf.internal.pageSize.getWidth() - 2 * margin;
                const pdfHeight = (imgProps.height * pdfWidth) / imgProps.width;

                if (yOffset + pdfHeight > pdf.internal.pageSize.getHeight() - margin) {
                    pdf.addPage();
                    yOffset = margin;
                }
                pdf.addImage(imgData, 'PNG', margin, yOffset, pdfWidth, pdfHeight);
                yOffset += pdfHeight + 5;
            }
        }
        
        // Add a new page for the summary statistics if they exist
        if (summaryContainer.children.length > 0) {
            pdf.addPage();
            yOffset = margin;
            
            // Add title for summary section
            pdf.setFontSize(18);
            pdf.text('Summary Statistics', 105, yOffset, null, null, 'center');
            yOffset += 15;
            
            const tempDiv = document.createElement('div');
            tempDiv.style.position = 'absolute';
            tempDiv.style.left = '-9999px';
            tempDiv.style.width = '180mm';
            tempDiv.innerHTML = summaryContainer.innerHTML;
            document.body.appendChild(tempDiv);
            
            const summaryCanvas = await html2canvas(tempDiv, { scale: 2 });
            const summaryImgData = summaryCanvas.toDataURL('image/png');
            const summaryImgProps = pdf.getImageProperties(summaryImgData);
            const summaryPdfHeight = (summaryImgProps.height * (pdf.internal.pageSize.getWidth() - 2 * margin)) / summaryImgProps.width;
            
            if (yOffset + summaryPdfHeight > pdf.internal.pageSize.getHeight() - margin) {
                pdf.addPage();
                yOffset = margin;
            }
            
            pdf.addImage(summaryImgData, 'PNG', margin, yOffset, pdf.internal.pageSize.getWidth() - 2 * margin, summaryPdfHeight);
            tempDiv.remove();
        }

        pdf.save("CDN_Data_Report.pdf");
    }

    document.addEventListener('DOMContentLoaded', () => {
        const loadGraphButton = document.getElementById('loadGraphButton');
        const generateAllGraphsButton = document.getElementById('generateAllGraphsButton');
        const saveAsPdfButton = document.getElementById('saveAsPdfButton');
        const dataTypeSelector = document.getElementById('dataType');
        const dateFromInput = document.getElementById('dateFrom');
        const dateToInput = document.getElementById('dateTo');
        const toggleRawDataButton = document.getElementById('toggleRawDataButton');
        const resultContainer = document.getElementById('resultContainer');

        dateFromInput.value = '2025-08-01';
        dateToInput.value = '2025-08-31';

        loadSingleGraph(dataTypeSelector.value);

        loadGraphButton.addEventListener('click', () => {
            loadSingleGraph(dataTypeSelector.value);
        });

        generateAllGraphsButton.addEventListener('click', () => {
            generateAllGraphs();
        });

        saveAsPdfButton.addEventListener('click', () => {
            saveAsPdf();
        });

        toggleRawDataButton.addEventListener('click', () => {
            if (resultContainer.style.display === 'none' || resultContainer.style.display === '') {
                resultContainer.style.display = 'block';
                toggleRawDataButton.textContent = 'Hide Raw Data';
            } else {
                resultContainer.style.display = 'none';
                toggleRawDataButton.textContent = 'Show Raw Data';
            }
        });
    });
</script>
</body>
</html>